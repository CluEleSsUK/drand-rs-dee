# dee: Rust implementation of drand

[![Documentation](https://img.shields.io/badge/docs-main-blue.svg)][Documentation]
![License](https://img.shields.io/crates/l/dee.svg)
[![crates.io](https://img.shields.io/crates/v/dee.svg)][Crates.io]

[Crates.io]: https://crates.io/crates/dee
[Documentation]: https://docs.rs/dee/

dee is a tool to retrieve public randomness generated by drand beacon. It features an HTTP client, and verification method.

The format specification is at [drand.love/docs/specification](https://drand.love/docs/specification/). drand was designed in [Scalable Bias-Resistant Distributed Randomness](https://eprint.iacr.org/2016/1067.pdf).

The reference interroperable Go implementation is available at [drand/drand](https://github.com/drand/drand).

## Install

```bash
cargo install dee
```

## Usage

```bash
dee remote add mainnet https://api.drand.sh # Add a new beacon
dee rand --set-upstream mainnet 1000 # Fetch round 1000 and set upstream to mainnet
dee rand --format json # Fetch latest mainnet round as json

dee remote add tlock https://drand.cloudflare.com/dbd506d6ef76e5f386f41c651dcb808c5bcbd75471cc4eafa3f4df7ad4e4c493 # Add a new beacon
dee remote info tlock # Retrieve information about testnet beacon

dee crypt --round 1000 --armor -o encrypted.pem test.txt # encrypt test.txt with timelock encryption
dee crypt --round 30s --armor -o encrypted.pem test.txt # encrypt test.txt for the round in 30s
dee crypt --round "2023-06-28 01:23:45" test.txt # encrypt test.txt for the round at a specific date and print on stdout
dee crypt --decrypt -o decrypted.txt encrypted.pem # decrypt encrypted.txt witg timelock encryption
```

## Seeding your Random Number Generator

You can leverage drand randomness as a seed for PRNG systems.

### bash

```bash
RANDOM=$(dee rand); echo $RANDOM $RANDOM $RANDOM
```

### Python

```python
import random

random.seed(int("dee-randomness", 16))

print(random.random())
print(random.random())
print(random.random())
```

### Rust

```rust
use rand::prelude::*;
use rand_seeder::{Seeder, SipHasher};
use rand_pcg::Pcg64;

fn main() {
    // In one line:
    let mut rng: Pcg64 = Seeder::from("dee-rng").make_rng();
    println!("{}", rng.gen_range(0..100));
    println!("{}", rng.gen_range(0..100));
    println!("{}", rng.gen_range(0..100));
}
```

## Details

This client supports validation of chained and unchained randomness, both with signature on G1 and on G2.